# 数据结构练习题
## 1001: 明明的随机数

>Description
明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

>Input
包含多组测试数据，每组测试数据占2行。
第1行为1个正整数，表示所生成的随机数的个数：N
第2行有N个用空格隔开的正整数，为所产生的随机数。

>Output
每组测试数据占2行。
第1行为1个正整数M，表示不相同的随机数的个数。
第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。

>Sample Input 
10
20 40 32 67 40 20 89 300 400 15

>Sample Output
8
15 20 32 40 67 89 300 400

```c
#include <iostream>
using namespace std;
int main()
{	
	int a[100],n,temp;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	
	//去重
	for(int i=0; i<n; i++){
		for(int j=i+1; j<n; j++){
            if(a[j]==a[i]){
                for(int k=j; k<n-1; k++)
                    a[k]=a[k+1];
                n--;
                j--;
            }
        }
	}
	//冒泡排序
	for(int i=0; i<n-1; i++){
		for(int j=0; j<n-1-i; j++){
            if(a[j]>a[j+1]){
                temp=a[j];
                a[j]=a[j+1];
                a[j+1]=temp;
            }
            
        }
	}
	//输出
	cout<<n<<endl;
	cout<<a[0];
    for(int i=1; i<n; i++){
        cout<<" "<<a[i];
    }
	cout<<endl;
	
}


```


## 1002: 车厢重组

>Description
在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转180度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。

>Input
包含多组测试数据，每组测试数据有两行数据，第一行是车厢总数N（不大于10000），第二行是N个不同的数表示初始的车厢顺序。

>Output
每组测试数据输出占一行，输出最少旋转次数。

>Sample Input 
4
4 3 2 1

>Sample Output
6

```c
#include <iostream>
using namespace std;
int main()
{	
	int n,a[100],temp,k=0;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	//冒泡排序
	for(int i=0; i<n-1; i++){
		for(int j=0; j<n-1-i; j++){
            if(a[j]>a[j+1]){
                temp=a[j];
                a[j]=a[j+1];
                a[j+1]=temp;
				k++;
            }
            
        }
	}
	cout<<k<<endl;
	return 0;
}
```

## 1003: 众数

>Description
给出N个1到30000间无序数正整数，其中1≤N≤10000，同一个正整数可能会出现多次，出现次数最多的整数称为众数。求出它的众数及它出现的次数。

>Input
包含多组测试数据，每组测试数据包含2行。
第一行是正整数的个数N，第二行开始为N个正整数。

>Output
每组测试数据输出有若干行，每行两个数，第1个是众数，第2个是众数出现的次数。
如有多个众数，按照从小到大的顺序输出。

>Sample Input 
12
2 4 2 3 2 5 3 7 2 3 4 3

>Sample Output
2 4
3 4

```c
#include <iostream>
using namespace std;
int main()
{	
	int a[30000]={0},n,temp=0,max=0;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>temp;
		a[temp]+=1;
	}
	
	//输出各个数的次数
	/*for(int j=0;j<100;j++){
		cout<<j<<" "<<a[j]<<endl;
	}*/

	//找出次数最多的是那个数
	for(int j=0;j<30000;j++){
		if(a[j]>max){
			max=a[j];
		}
	}
	
	//输出次数最多的：
	for(int j=0;j<30000;j++){
		if(a[j]==max){
			cout<<j<<" "<<a[j]<<endl;
		}
	}

return 0;
}
```

## 1004: 军事机密

>Description
       军方截获的信息由n（n<=30000）个数字组成，因为是敌国的高端秘密，所以一时不能破获。最原始的想法就是对这n个数进行小到大排序，每个数都对应一个序号，然后对第i个是什么数感兴趣，现在要求编程完成。

>Input
包含多组测试数据，每组测试数据的第一行n，接着是n个截获的数字，接着一行是数字k，接着是k行要输出数的序号。

>Output
k行序号对应的数字。
Sample Input 
5
121 1 126 123 7
3
2
4
3

>Sample Output
7
123
121

```c
#include <iostream>
using namespace std;
int main()
{	
	int a[30000],n,t=0,k,b[100];
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	//输入数字k,k个序号
	cin>>k;
	for(int i=0;i<k;i++){
		cin>>b[i];
	}

	//排序：
	for(int i=0;i<n;i++){
		for(int j=0;j<n-i-1;j++){
			if(a[j]>a[j+1]){
				t=a[j];
				a[j]=a[j+1];
				a[j+1]=t;
			}
		}
	
	}
	//输出排序好的序列：
	/*for(int i=0;i<n;i++){
		cout<<a[i]<<endl;
	}*/

	//输出k个序号对应的a数组中的数字
	for(int i=0;i<k;i++){
		cout<<a[b[i]-1]<<endl;
	}
	

return 0;
}
```


## 1005: 奖学金

>Description
某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。
>1. 任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前5名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据（每行输出两个数：学号、总分）是：
    7 279
    5 279
>2. 这两行数据的含义是：总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是279（总分等于输入的语文、数学、英语三科成绩之和），但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是：
    5 279
    7 279
>3. 则按输出错误处理，不能得分。0

>Input
包含多组测试数据。每组测试数据包含多行。
第1行为一个正整数n，表示该校参加评选的学生人数（n>5且不超过300）。
第2到n+1行，每行有3个用空格隔开的数字，每个数字都在0到100之间。第j行的3个数字依次表示学号为j-1的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为1~n（恰好是输入数据的行号减1）。
所给的数据都是正确的，不必检验。

>Output
每组测试数据的输出共有5行，每行是两个用空格隔开的正整数, 依次表示前5名学生的学号和总分。

>Sample Input 
6
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98
8
80 89 89
88 98 78
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98

>Sample Output
6 265
4 264
3 258
2 244
1 237
8 265
2 264
6 264
1 258
5 258


```c
#include <iostream>
using namespace std;
typedef struct{
	int num;
	int yw;
	int sx;
	int yy;
	int sum;
}stu;
int main()
{	
	int n;
	stu s[100],t;
	cin>>n;
	for(int i=0;i<n;i++){
		s[i].num=i+1;
		cin>>s[i].yw>>s[i].sx>>s[i].yy;
		s[i].sum=s[i].yw+s[i].sx+s[i].yy;
	}

	//总分排序,总分相等，按语文成绩排序，从大到小
	for(int i=0;i<n;i++){
		for(int j=0;j<n-1-i;j++){
			if(s[j].sum<s[j+1].sum){
				t=s[j];
				s[j]=s[j+1];
				s[j+1]=t;
			}else if(s[j].sum==s[j+1].sum){
				if(s[j].yw<s[j+1].yw){
					t=s[j];
					s[j]=s[j+1];
					s[j+1]=t;
				}
			}
		}
	}

	//输出前五名：
	for(int i=0;i<5;i++){
		cout<<s[i].num<<" "<<s[i].sum<<endl;
	}

return 0;
}
```

## 1006: 统计数字

>Description
某次科研调查时得到了n个自然数，每个数均不超过1500000000。已知不相同的数不超过10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。

>Input
包含多组测试数据，每组测试数据包含多行。
第1行是整数n，表示自然数的个数（1<=n<=200000）。  
第2行包括n个自然数，每个数均不超过1500000000。

>Output
每组测试数据包含m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。
每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。

>Sample Input 
8
2 4 2 4 5 100 2 100

>Sample Output
2 3
4 2
5 1
100 2

```c
#include <iostream>
using namespace std;
int main()
{	
	int a[200000]={0};
	int n,t,k=0;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>t;
		a[t]++;
	}

	for(int i=0;i<101;i++){
		if(a[i]!=0){
			cout<<i<<" "<<a[i]<<endl;
		}
	}

	return 0;
}
```


## 1007: 输油管道问题

>Description
某石油公司计划建造一条由东向西的主输油管道。该管道要穿过一个有n 口油井的油田。从每口油井都要有一条输油管道沿最短路经(或南或北)与主管道相连。如果给定n口油井的位置，即它们的x 坐标（东西向）和y 坐标（南北向），应如何确定主管道的最优位置，即使各油井到主管道之间的输油管道长度总和最小的位置？证明可在线性时间内确定主管道的最优位置。
给定n 口油井的位置,编程计算各油井到主管道之间的输油管道最小长度总和。

>Input
包含多组测试数据，每组测试数据的第1 行是油井数n（1≤n≤10000）。接下来n 行是油井的位置，每行2个整数x和y，-10000≤x,y≤10000。

>Output
每组测试数据占一行，包括一个整数，是油井到主管道之间的输油管道最小长度总和。

>Sample Input 
5
1 2
2 2
1 3
3 -2
3 3

>Sample Output
6


## 1008: 士兵站队问题

>Description
在一个划分成网格的操场上，n个士兵散乱地站在网格点上。网格点由整数坐标(x,y)表示。士兵们可以沿网格边上、下、左、右移动一步，但在同一时刻任一网格点上只能有一名士兵。按照军官的命令，士兵们要整齐地列成一个水平队列，即排列成(x,y),(x+1,y),…,(x+n-1,y)。如何选择x 和y的值才能使士兵们以最少的总移动步数排成一列。
计算使所有士兵排成一行需要的最少移动步数。

>Input
包含多组测试数据。
第1 行是士兵数n（1≤n≤10000）。接下来n 行是士兵的初始位置，每行2 个整数x 和y，-10000≤x，y≤10000。

>Output
每组测试数据输出占一行，包括一个整数，即士兵排成一行需要的最少移动步数。

>Sample Input 
5
1 2
2 2
1 3
3 -2
3 3

>Sample Output
8


## 1009: 第k小整数

>Description
现有n个正整数，n≤10000，要求出这n个正整数中的第k个最小整数（相同大小的整数只计算一次），k≤1000，正整数均小于30000。

>Input
包含多组测试数据，每组测试数据第一行为n和k，第二行开始为n个正整数的值，整数间用空格隔开。

>Output
第k个最小整数的值；若无解，则输出“NO RESULT”。

>Sample Input 
10 3
1 3 3 7 2 5 1 2 4 6

>Sample Output
3
